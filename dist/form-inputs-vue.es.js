var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { openBlock, createBlock, createVNode, unref, computed, getCurrentInstance, ref, onBeforeMount, watch, reactive, isRef, isReactive, isReadonly, onBeforeUnmount, inject, provide, nextTick, defineComponent, createElementBlock, createElementVNode, normalizeClass, createCommentVNode, withDirectives, vModelText, Fragment, renderList, toDisplayString, onMounted, withModifiers } from "vue";
var index = "";
function render$g(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M16 12a4 4 0 10-8 0 4 4 0 008 0zm0 0v1.5a2.5 2.5 0 005 0V12a9 9 0 10-9 9m4.5-1.206a8.959 8.959 0 01-4.5 1.207"
    })
  ]);
}
function render$f(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
    })
  ]);
}
function render$e(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"
    })
  ]);
}
function render$d(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 12a3 3 0 11-6 0 3 3 0 016 0z"
    }),
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"
    })
  ]);
}
function render$c(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M7 20l4-16m2 16l4-16M6 9h14M4 15h14"
    })
  ]);
}
function render$b(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"
    })
  ]);
}
function render$a(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M10 6H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V8a2 2 0 00-2-2h-5m-4 0V5a2 2 0 114 0v1m-4 0a2 2 0 104 0m-5 8a2 2 0 100-4 2 2 0 000 4zm0 0c1.306 0 2.417.835 2.83 2M9 14a3.001 3.001 0 00-2.83 2M15 11h3m-3 4h2"
    })
  ]);
}
function render$9(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"
    })
  ]);
}
function render$8(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"
    }),
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15 11a3 3 0 11-6 0 3 3 0 016 0z"
    })
  ]);
}
function render$7(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"
    })
  ]);
}
function render$6(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7"
    })
  ]);
}
function render$5(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"
    })
  ]);
}
function render$4(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M3 5a2 2 0 012-2h3.28a1 1 0 01.948.684l1.498 4.493a1 1 0 01-.502 1.21l-2.257 1.13a11.042 11.042 0 005.516 5.516l1.13-2.257a1 1 0 011.21-.502l4.493 1.498a1 1 0 01.684.949V19a2 2 0 01-2 2h-1C9.716 21 3 14.284 3 6V5z"
    })
  ]);
}
function render$3(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
    })
  ]);
}
function render$2(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
    })
  ]);
}
function render$1(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"
    })
  ]);
}
function render(_ctx, _cache) {
  return openBlock(), createBlock("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor",
    "aria-hidden": "true"
  }, [
    createVNode("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      "stroke-width": "2",
      d: "M6 18L18 6M6 6l12 12"
    })
  ]);
}
function isFunction$1(val) {
  return typeof val === "function";
}
function isObject(o) {
  return o !== null && typeof o === "object" && !Array.isArray(o);
}
function normalizeValidatorObject(validator) {
  return isFunction$1(validator.$validator) ? Object.assign({}, validator) : {
    $validator: validator
  };
}
function unwrapValidatorResponse(result) {
  if (typeof result === "object")
    return result.$valid;
  return result;
}
function unwrapNormalizedValidator(validator) {
  return validator.$validator || validator;
}
function withParams($params, $validator) {
  if (!isObject($params))
    throw new Error(`[@vuelidate/validators]: First parameter to "withParams" should be an object, provided ${typeof $params}`);
  if (!isObject($validator) && !isFunction$1($validator))
    throw new Error(`[@vuelidate/validators]: Validator must be a function or object with $validator parameter`);
  const validatorObj = normalizeValidatorObject($validator);
  validatorObj.$params = Object.assign({}, validatorObj.$params || {}, $params);
  return validatorObj;
}
function withMessage($message, $validator) {
  if (!isFunction$1($message) && typeof unref($message) !== "string")
    throw new Error(`[@vuelidate/validators]: First parameter to "withMessage" should be string or a function returning a string, provided ${typeof $message}`);
  if (!isObject($validator) && !isFunction$1($validator))
    throw new Error(`[@vuelidate/validators]: Validator must be a function or object with $validator parameter`);
  const validatorObj = normalizeValidatorObject($validator);
  validatorObj.$message = $message;
  return validatorObj;
}
function withAsync($validator, $watchTargets = []) {
  const validatorObj = normalizeValidatorObject($validator);
  return Object.assign({}, validatorObj, {
    $async: true,
    $watchTargets
  });
}
function forEach(validators) {
  return {
    $validator(collection, ...others) {
      return unref(collection).reduce((previous, collectionItem) => {
        const collectionEntryResult = Object.entries(collectionItem).reduce((all, [property, $model]) => {
          const innerValidators = validators[property] || {};
          const propertyResult = Object.entries(innerValidators).reduce((all2, [validatorName, currentValidator]) => {
            const validatorFunction = unwrapNormalizedValidator(currentValidator);
            const $response = validatorFunction.call(this, $model, collectionItem, ...others);
            const $valid = unwrapValidatorResponse($response);
            all2.$data[validatorName] = $response;
            all2.$data.$invalid = !$valid || !!all2.$data.$invalid;
            all2.$data.$error = all2.$data.$invalid;
            if (!$valid) {
              let $message = currentValidator.$message || "";
              const $params = currentValidator.$params || {};
              if (typeof $message === "function") {
                $message = $message({
                  $pending: false,
                  $invalid: !$valid,
                  $params,
                  $model,
                  $response
                });
              }
              all2.$errors.push({
                $property: property,
                $message,
                $params,
                $response,
                $model,
                $pending: false,
                $validator: validatorName
              });
            }
            return {
              $valid: all2.$valid && $valid,
              $data: all2.$data,
              $errors: all2.$errors
            };
          }, {
            $valid: true,
            $data: {},
            $errors: []
          });
          all.$data[property] = propertyResult.$data;
          all.$errors[property] = propertyResult.$errors;
          return {
            $valid: all.$valid && propertyResult.$valid,
            $data: all.$data,
            $errors: all.$errors
          };
        }, {
          $valid: true,
          $data: {},
          $errors: {}
        });
        return {
          $valid: previous.$valid && collectionEntryResult.$valid,
          $data: previous.$data.concat(collectionEntryResult.$data),
          $errors: previous.$errors.concat(collectionEntryResult.$errors)
        };
      }, {
        $valid: true,
        $data: [],
        $errors: []
      });
    },
    $message: ({
      $response
    }) => $response ? $response.$errors.map((context) => {
      return Object.values(context).map((errors) => errors.map((error) => error.$message)).reduce((a, b) => a.concat(b), []);
    }) : []
  };
}
const req = (value) => {
  value = unref(value);
  if (Array.isArray(value))
    return !!value.length;
  if (value === void 0 || value === null) {
    return false;
  }
  if (value === false) {
    return true;
  }
  if (value instanceof Date) {
    return !isNaN(value.getTime());
  }
  if (typeof value === "object") {
    for (let _ in value)
      return true;
    return false;
  }
  return !!String(value).length;
};
const len = (value) => {
  value = unref(value);
  if (Array.isArray(value))
    return value.length;
  if (typeof value === "object") {
    return Object.keys(value).length;
  }
  return String(value).length;
};
function regex(expr) {
  return (value) => {
    value = unref(value);
    return !req(value) || expr.test(value);
  };
}
var common = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  withParams,
  withMessage,
  withAsync,
  forEach,
  req,
  len,
  regex,
  unwrap: unref,
  unwrapNormalizedValidator,
  unwrapValidatorResponse,
  normalizeValidatorObject
});
const emailRegex = /^(?:[A-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[A-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9]{2,}(?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/i;
var email$1 = regex(emailRegex);
var email = {
  $validator: email$1,
  $message: "Value is not a valid email address",
  $params: {
    type: "email"
  }
};
function required$1(value) {
  if (typeof value === "string") {
    value = value.trim();
  }
  return req(value);
}
var required = {
  $validator: required$1,
  $message: "Value is required",
  $params: {
    type: "required"
  }
};
function unwrapObj(obj, ignoreKeys = []) {
  return Object.keys(obj).reduce((o, k) => {
    if (ignoreKeys.includes(k))
      return o;
    o[k] = unref(obj[k]);
    return o;
  }, {});
}
function isFunction(val) {
  return typeof val === "function";
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function _empty() {
}
const ROOT_PATH = "__root";
function _call(body, then, direct) {
  if (direct) {
    return then ? then(body()) : body();
  }
  try {
    var result = Promise.resolve(body());
    return then ? result.then(then) : result;
  } catch (e) {
    return Promise.reject(e);
  }
}
function _callIgnored(body, direct) {
  return _call(body, _empty, direct);
}
function _invoke(body, then) {
  var result = body();
  if (result && result.then) {
    return result.then(then);
  }
  return then(result);
}
function _async(f) {
  return function() {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}
function sortValidations(validationsRaw = {}) {
  const validations = unref(validationsRaw);
  const validationKeys = Object.keys(validations);
  const rules = {};
  const nestedValidators = {};
  const config = {};
  validationKeys.forEach((key) => {
    const v = validations[key];
    switch (true) {
      case isFunction(v.$validator):
        rules[key] = v;
        break;
      case isFunction(v):
        rules[key] = {
          $validator: v
        };
        break;
      case key.startsWith("$"):
        config[key] = v;
        break;
      default:
        nestedValidators[key] = v;
    }
  });
  return {
    rules,
    nestedValidators,
    config
  };
}
function callRule(rule, value, instance) {
  const v = unref(value);
  return rule.call(instance, v, instance);
}
function normalizeValidatorResponse(result) {
  return result.$valid !== void 0 ? !result.$valid : !result;
}
function createAsyncResult(rule, model, $pending, $dirty, {
  $lazy,
  $rewardEarly
}, $response, instance, watchTargets = [], $lastInvalidState, $lastCommittedOn) {
  const $invalid = ref(!!$dirty.value);
  const $pendingCounter = ref(0);
  $pending.value = false;
  const $unwatch = watch([model, $dirty].concat(watchTargets, $lastCommittedOn), () => {
    if ($lazy && !$dirty.value || $rewardEarly && !$lastInvalidState.value && !$pending.value) {
      return;
    }
    let ruleResult;
    try {
      ruleResult = callRule(rule, model, instance);
    } catch (err) {
      ruleResult = Promise.reject(err);
    }
    $pendingCounter.value++;
    $pending.value = !!$pendingCounter.value;
    $invalid.value = false;
    Promise.resolve(ruleResult).then((data) => {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = data;
      $invalid.value = normalizeValidatorResponse(data);
    }).catch((error) => {
      $pendingCounter.value--;
      $pending.value = !!$pendingCounter.value;
      $response.value = error;
      $invalid.value = true;
    });
  }, {
    immediate: true,
    deep: typeof model === "object"
  });
  return {
    $invalid,
    $unwatch
  };
}
function createSyncResult(rule, model, $dirty, {
  $lazy,
  $rewardEarly
}, $response, instance, $lastInvalidState) {
  const $unwatch = () => ({});
  const $invalid = computed(() => {
    if ($lazy && !$dirty.value || $rewardEarly && !$lastInvalidState.value) {
      return false;
    }
    let returnValue = true;
    try {
      const result = callRule(rule, model, instance);
      $response.value = result;
      returnValue = normalizeValidatorResponse(result);
    } catch (err) {
      $response.value = err;
    }
    return returnValue;
  });
  return {
    $unwatch,
    $invalid
  };
}
function createValidatorResult(rule, model, $dirty, config, instance, validatorName, propertyKey, propertyPath, $lastInvalidState, $lastCommittedOn) {
  const $pending = ref(false);
  const $params = rule.$params || {};
  const $response = ref(null);
  let $invalid;
  let $unwatch;
  if (rule.$async) {
    ({
      $invalid,
      $unwatch
    } = createAsyncResult(rule.$validator, model, $pending, $dirty, config, $response, instance, rule.$watchTargets, $lastInvalidState, $lastCommittedOn));
  } else {
    ({
      $invalid,
      $unwatch
    } = createSyncResult(rule.$validator, model, $dirty, config, $response, instance, $lastInvalidState));
  }
  const message = rule.$message;
  const $message = isFunction(message) ? computed(() => message(unwrapObj({
    $pending,
    $invalid,
    $params: unwrapObj($params),
    $model: model,
    $response,
    $validator: validatorName,
    $propertyPath: propertyPath,
    $property: propertyKey
  }))) : message || "";
  return {
    $message,
    $params,
    $pending,
    $invalid,
    $response,
    $unwatch
  };
}
function createValidationResults(rules, model, key, resultsCache, path, config, instance, externalResults) {
  const ruleKeys = Object.keys(rules);
  const cachedResult = resultsCache.get(path, rules);
  const $dirty = ref(false);
  const $lastInvalidState = ref(false);
  const $lastCommittedOn = ref(true);
  if (cachedResult) {
    if (!cachedResult.$partial)
      return cachedResult;
    cachedResult.$unwatch();
    $dirty.value = cachedResult.$dirty.value;
  }
  const result = {
    $dirty,
    $path: path,
    $touch: () => {
      if (!$dirty.value)
        $dirty.value = true;
    },
    $reset: () => {
      if ($dirty.value)
        $dirty.value = false;
    },
    $commit: () => {
    }
  };
  if (!ruleKeys.length) {
    cachedResult && resultsCache.set(path, rules, result);
    return result;
  }
  ruleKeys.forEach((ruleKey) => {
    result[ruleKey] = createValidatorResult(rules[ruleKey], model, result.$dirty, config, instance, ruleKey, key, path, $lastInvalidState, $lastCommittedOn);
  });
  result.$externalResults = computed(() => {
    if (!externalResults.value)
      return [];
    return [].concat(externalResults.value).map((stringError, index2) => ({
      $propertyPath: path,
      $property: key,
      $validator: "$externalResults",
      $uid: `${path}-externalResult-${index2}`,
      $message: stringError,
      $params: {},
      $response: null,
      $pending: false
    }));
  });
  result.$invalid = computed(() => {
    const r = ruleKeys.some((ruleKey) => unref(result[ruleKey].$invalid));
    $lastInvalidState.value = r;
    return !!result.$externalResults.value.length || r;
  });
  result.$pending = computed(() => ruleKeys.some((ruleKey) => unref(result[ruleKey].$pending)));
  result.$error = computed(() => result.$dirty.value ? result.$pending.value || result.$invalid.value : false);
  result.$silentErrors = computed(() => ruleKeys.filter((ruleKey) => unref(result[ruleKey].$invalid)).map((ruleKey) => {
    const res = result[ruleKey];
    return reactive({
      $propertyPath: path,
      $property: key,
      $validator: ruleKey,
      $uid: `${path}-${ruleKey}`,
      $message: res.$message,
      $params: res.$params,
      $response: res.$response,
      $pending: res.$pending
    });
  }).concat(result.$externalResults.value));
  result.$errors = computed(() => result.$dirty.value ? result.$silentErrors.value : []);
  result.$unwatch = () => ruleKeys.forEach((ruleKey) => {
    result[ruleKey].$unwatch();
  });
  result.$commit = () => {
    $lastInvalidState.value = true;
    $lastCommittedOn.value = Date.now();
  };
  resultsCache.set(path, rules, result);
  return result;
}
function collectNestedValidationResults(validations, nestedState, path, resultsCache, config, instance, nestedExternalResults) {
  const nestedValidationKeys = Object.keys(validations);
  if (!nestedValidationKeys.length)
    return {};
  return nestedValidationKeys.reduce((results, nestedKey) => {
    results[nestedKey] = setValidations({
      validations: validations[nestedKey],
      state: nestedState,
      key: nestedKey,
      parentKey: path,
      resultsCache,
      globalConfig: config,
      instance,
      externalResults: nestedExternalResults
    });
    return results;
  }, {});
}
function createMetaFields(results, nestedResults, childResults) {
  const allResults = computed(() => [nestedResults, childResults].filter((res) => res).reduce((allRes, res) => {
    return allRes.concat(Object.values(unref(res)));
  }, []));
  const $dirty = computed({
    get() {
      return results.$dirty.value || (allResults.value.length ? allResults.value.every((r) => r.$dirty) : false);
    },
    set(v) {
      results.$dirty.value = v;
    }
  });
  const $silentErrors = computed(() => {
    const modelErrors = unref(results.$silentErrors) || [];
    const nestedErrors = allResults.value.filter((result) => (unref(result).$silentErrors || []).length).reduce((errors, result) => {
      return errors.concat(...result.$silentErrors);
    }, []);
    return modelErrors.concat(nestedErrors);
  });
  const $errors = computed(() => {
    const modelErrors = unref(results.$errors) || [];
    const nestedErrors = allResults.value.filter((result) => (unref(result).$errors || []).length).reduce((errors, result) => {
      return errors.concat(...result.$errors);
    }, []);
    return modelErrors.concat(nestedErrors);
  });
  const $invalid = computed(() => allResults.value.some((r) => r.$invalid) || unref(results.$invalid) || false);
  const $pending = computed(() => allResults.value.some((r) => unref(r.$pending)) || unref(results.$pending) || false);
  const $anyDirty = computed(() => allResults.value.some((r) => r.$dirty) || allResults.value.some((r) => r.$anyDirty) || $dirty.value);
  const $error = computed(() => $dirty.value ? $pending.value || $invalid.value : false);
  const $touch = () => {
    results.$touch();
    allResults.value.forEach((result) => {
      result.$touch();
    });
  };
  const $commit = () => {
    results.$commit();
    allResults.value.forEach((result) => {
      result.$commit();
    });
  };
  const $reset = () => {
    results.$reset();
    allResults.value.forEach((result) => {
      result.$reset();
    });
  };
  if (allResults.value.length && allResults.value.every((nr) => nr.$dirty))
    $touch();
  return {
    $dirty,
    $errors,
    $invalid,
    $anyDirty,
    $error,
    $pending,
    $touch,
    $reset,
    $silentErrors,
    $commit
  };
}
function setValidations({
  validations,
  state,
  key,
  parentKey,
  childResults,
  resultsCache,
  globalConfig = {},
  instance,
  externalResults
}) {
  const $validate = _async(function() {
    if (!$dirty.value)
      $touch();
    return _invoke(function() {
      if (mergedConfig.$rewardEarly) {
        $commit();
        return _callIgnored(nextTick);
      }
    }, function() {
      return _call(nextTick, function() {
        return new Promise((resolve) => {
          if (!$pending.value)
            return resolve(!$invalid.value);
          const unwatch = watch($pending, () => {
            resolve(!$invalid.value);
            unwatch();
          });
        });
      });
    });
  });
  const path = parentKey ? `${parentKey}.${key}` : key;
  const {
    rules,
    nestedValidators,
    config
  } = sortValidations(validations);
  const mergedConfig = Object.assign({}, globalConfig, config);
  const nestedState = key ? computed(() => {
    const s = unref(state);
    return s ? unref(s[key]) : void 0;
  }) : state;
  const cachedExternalResults = Object.assign({}, unref(externalResults) || {});
  const nestedExternalResults = computed(() => {
    const results2 = unref(externalResults);
    if (!key)
      return results2;
    return results2 ? unref(results2[key]) : void 0;
  });
  const results = createValidationResults(rules, nestedState, key, resultsCache, path, mergedConfig, instance, nestedExternalResults);
  const nestedResults = collectNestedValidationResults(nestedValidators, nestedState, path, resultsCache, mergedConfig, instance, nestedExternalResults);
  const {
    $dirty,
    $errors,
    $invalid,
    $anyDirty,
    $error,
    $pending,
    $touch,
    $reset,
    $silentErrors,
    $commit
  } = createMetaFields(results, nestedResults, childResults);
  const $model = key ? computed({
    get: () => unref(nestedState),
    set: (val) => {
      $dirty.value = true;
      const s = unref(state);
      const external = unref(externalResults);
      if (external) {
        external[key] = cachedExternalResults[key];
      }
      if (isRef(s[key])) {
        s[key].value = val;
      } else {
        s[key] = val;
      }
    }
  }) : null;
  if (key && mergedConfig.$autoDirty) {
    watch(nestedState, () => {
      if (!$dirty.value)
        $touch();
      const external = unref(externalResults);
      if (external) {
        external[key] = cachedExternalResults[key];
      }
    }, {
      flush: "sync"
    });
  }
  function $getResultsForChild(key2) {
    return (childResults.value || {})[key2];
  }
  function $clearExternalResults() {
    if (isRef(externalResults)) {
      externalResults.value = cachedExternalResults;
    } else {
      if (Object.keys(cachedExternalResults).length === 0) {
        Object.keys(externalResults).forEach((k) => {
          delete externalResults[k];
        });
      } else {
        Object.assign(externalResults, cachedExternalResults);
      }
    }
  }
  return reactive(Object.assign({}, results, {
    $model,
    $dirty,
    $error,
    $errors,
    $invalid,
    $anyDirty,
    $pending,
    $touch,
    $reset,
    $path: path || ROOT_PATH,
    $silentErrors,
    $validate,
    $commit
  }, childResults && {
    $getResultsForChild,
    $clearExternalResults
  }, nestedResults));
}
class ResultsStorage {
  constructor() {
    this.storage = new Map();
  }
  set(path, rules, result) {
    this.storage.set(path, {
      rules,
      result
    });
  }
  checkRulesValidity(path, rules, storedRules) {
    const storedRulesKeys = Object.keys(storedRules);
    const newRulesKeys = Object.keys(rules);
    if (newRulesKeys.length !== storedRulesKeys.length)
      return false;
    const hasAllValidators = newRulesKeys.every((ruleKey) => storedRulesKeys.includes(ruleKey));
    if (!hasAllValidators)
      return false;
    return newRulesKeys.every((ruleKey) => {
      if (!rules[ruleKey].$params)
        return true;
      return Object.keys(rules[ruleKey].$params).every((paramKey) => {
        return unref(storedRules[ruleKey].$params[paramKey]) === unref(rules[ruleKey].$params[paramKey]);
      });
    });
  }
  get(path, rules) {
    const storedRuleResultPair = this.storage.get(path);
    if (!storedRuleResultPair)
      return void 0;
    const {
      rules: storedRules,
      result
    } = storedRuleResultPair;
    const isValidCache = this.checkRulesValidity(path, rules, storedRules);
    const $unwatch = result.$unwatch ? result.$unwatch : () => ({});
    if (!isValidCache)
      return {
        $dirty: result.$dirty,
        $partial: true,
        $unwatch
      };
    return result;
  }
}
const VuelidateInjectChildResults = Symbol("vuelidate#injectChiildResults");
const VuelidateRemoveChildResults = Symbol("vuelidate#removeChiildResults");
const CollectFlag = {
  COLLECT_ALL: true,
  COLLECT_NONE: false
};
function nestedValidations({
  $scope
}) {
  const childResultsRaw = {};
  const childResultsKeys = ref([]);
  const childResults = computed(() => childResultsKeys.value.reduce((results, key) => {
    results[key] = unref(childResultsRaw[key]);
    return results;
  }, {}));
  function injectChildResultsIntoParent(results, {
    $registerAs: key,
    $scope: childScope,
    $stopPropagation
  }) {
    if ($stopPropagation || $scope === CollectFlag.COLLECT_NONE || childScope === CollectFlag.COLLECT_NONE || $scope !== CollectFlag.COLLECT_ALL && $scope !== childScope)
      return;
    childResultsRaw[key] = results;
    childResultsKeys.value.push(key);
  }
  function removeChildResultsFromParent(key) {
    childResultsKeys.value = childResultsKeys.value.filter((childKey) => childKey !== key);
    delete childResultsRaw[key];
  }
  const sendValidationResultsToParent = inject(VuelidateInjectChildResults, () => {
  });
  provide(VuelidateInjectChildResults, injectChildResultsIntoParent);
  const removeValidationResultsFromParent = inject(VuelidateRemoveChildResults, () => {
  });
  provide(VuelidateRemoveChildResults, removeChildResultsFromParent);
  return {
    childResults,
    sendValidationResultsToParent,
    removeValidationResultsFromParent
  };
}
function useVuelidate(validations, state, globalConfig = {}) {
  if (arguments.length === 1) {
    globalConfig = validations;
    validations = void 0;
    state = void 0;
  }
  let {
    $registerAs,
    $scope = CollectFlag.COLLECT_ALL,
    $stopPropagation,
    $externalResults
  } = globalConfig;
  const instance = getCurrentInstance();
  const componentOptions = instance ? instance.type : {};
  if (!$registerAs && instance) {
    const uid = instance.uid || instance._uid;
    $registerAs = `_vuelidate_${uid}`;
  }
  const validationResults = ref({});
  const resultsCache = new ResultsStorage();
  const {
    childResults,
    sendValidationResultsToParent,
    removeValidationResultsFromParent
  } = instance ? nestedValidations({
    $scope
  }) : {
    childResults: ref({})
  };
  if (!validations && componentOptions.validations) {
    const rules = componentOptions.validations;
    state = ref({});
    onBeforeMount(() => {
      state.value = instance.proxy;
      function ComputedProxyFactory(target) {
        return new Proxy(target, {
          get(target2, prop, receiver) {
            return typeof target2[prop] === "object" ? ComputedProxyFactory(target2[prop]) : computed(() => target2[prop]);
          }
        });
      }
      watch(() => isFunction(rules) ? rules.call(state.value, new ComputedProxyFactory(state.value)) : rules, (validations2) => {
        validationResults.value = setValidations({
          validations: validations2,
          state,
          childResults,
          resultsCache,
          globalConfig,
          instance: instance.proxy,
          externalResults: $externalResults || instance.proxy.vuelidateExternalResults
        });
      }, {
        immediate: true
      });
    });
    globalConfig = componentOptions.validationsConfig || globalConfig;
  } else {
    const validationsWatchTarget = isRef(validations) || isProxy(validations) ? validations : reactive(validations || {});
    watch(validationsWatchTarget, (newValidationRules) => {
      validationResults.value = setValidations({
        validations: newValidationRules,
        state,
        childResults,
        resultsCache,
        globalConfig,
        instance: instance ? instance.proxy : {},
        externalResults: $externalResults
      });
    }, {
      immediate: true
    });
  }
  if (instance) {
    sendValidationResultsToParent(validationResults, {
      $registerAs,
      $scope,
      $stopPropagation
    });
    onBeforeUnmount(() => removeValidationResultsFromParent($registerAs));
  }
  return computed(() => {
    return Object.assign({}, unref(validationResults.value), childResults.value);
  });
}
const commonProps = {
  required: {
    type: Boolean,
    default: false
  },
  externalDescribeIcon: {
    type: Boolean,
    default: true
  },
  inputValue: {
    type: String,
    default: ""
  }
};
function inputClass(externalDescribeIcon, validation) {
  return computed(() => {
    const inputClass2 = [];
    if (externalDescribeIcon)
      inputClass2.push("rounded-r-md");
    else
      inputClass2.push("rounded-md");
    inputClass2.push(validation.$error ? "border-red-400 focus:border-red-400 focus:ring-1 focus:ring-red-400" : "");
    return inputClass2;
  });
}
function labelSpanClass(externalDescribeIcon, state, statePropName) {
  return computed(() => {
    const labelSpanClass2 = [];
    labelSpanClass2.push(state.focus || state[statePropName] ? "text-sm text-gray-700 top-1" : "top-1/2 text-gray-500");
    if (externalDescribeIcon)
      labelSpanClass2.push(state.focus || state[statePropName] ? "left-10" : "left-14");
    else
      labelSpanClass2.push(state.focus || state[statePropName] ? "left-2" : "left-4");
    return labelSpanClass2;
  });
}
const _hoisted_1$a = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$a = ["required"];
const _hoisted_3$9 = { key: 0 };
const _hoisted_4$9 = { class: "ml-2 text-red-600" };
const _sfc_main$a = /* @__PURE__ */ defineComponent({
  props: __spreadValues({}, commonProps),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      address: props.inputValue
    });
    watch(() => props.inputValue, (newValue) => state.address = newValue);
    const rules = computed(() => ({
      address: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.address = __spreadProps(__spreadValues({}, rules.value.address), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.address);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "address");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "addressHasError" });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$a, [
            createVNode(unref(render$b))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "Endere\xE7o", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).address.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).address = $event),
            autocomplete: "nop",
            type: "text",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: _cache[1] || (_cache[1] = () => emit("value", unref(state).address))
          }, null, 42, _hoisted_2$a), [
            [
              vModelText,
              unref(state).address,
              void 0,
              { trim: true }
            ]
          ])
        ], 2),
        unref(v$).address.$error ? (openBlock(), createElementBlock("span", _hoisted_3$9, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).address.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_4$9, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var lib = {};
var cepMask$1 = {};
Object.defineProperty(cepMask$1, "__esModule", { value: true });
cepMask$1.cepMask = void 0;
var cepMask = function(e) {
  var element = e.target;
  element.value = element.value.replace(/\D/g, "");
  if (element.value.length > 8) {
    element.value = element.value.slice(0, 8);
  }
  switch (element.value.length) {
    case 3:
    case 4:
    case 5:
      element.value = element.value.replace(/(\d{2})(\d+)/, "$1.$2");
      break;
    case 6:
    case 7:
    case 8:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d+)/, "$1.$2-$3");
      break;
  }
};
cepMask$1.cepMask = cepMask;
var cpfMask$1 = {};
var chunkSubstr$1 = {};
Object.defineProperty(chunkSubstr$1, "__esModule", { value: true });
function chunkSubstr(str, size) {
  var numChunks = Math.ceil(str.length / size);
  var chunks = new Array(numChunks);
  for (var i = 0, o = 0; i < numChunks; ++i, o += size) {
    chunks[i] = str.slice(o, o + size);
  }
  return chunks;
}
chunkSubstr$1.default = chunkSubstr;
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cpfMask$1, "__esModule", { value: true });
cpfMask$1.cpfMask = void 0;
var chunkSubstr_1$1 = __importDefault$1(chunkSubstr$1);
var cpfMask = function(e) {
  var element = e.target;
  element.value = element.value.replace(/\D/g, "");
  if (element.value.length > 11) {
    element.value = element.value.slice(0, 11);
  }
  var arr = [""];
  switch (element.value.length) {
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      arr = (0, chunkSubstr_1$1.default)(element.value, 3);
      element.value = arr.join(".");
      break;
    case 10:
    case 11:
      element.value = element.value.replace(/(\d{3})(\d{3})(\d{3})(\d+)/, "$1.$2.$3-$4");
      break;
  }
};
cpfMask$1.cpfMask = cpfMask;
var cnpjMask$1 = {};
Object.defineProperty(cnpjMask$1, "__esModule", { value: true });
cnpjMask$1.cnpjMask = void 0;
var cnpjMask = function(e) {
  var element = e.target;
  element.value = element.value.replace(/\D/g, "");
  if (element.value.length > 14) {
    element.value = element.value.slice(0, 14);
  }
  switch (element.value.length) {
    case 3:
    case 4:
    case 5:
      element.value = element.value.replace(/(\d{2})(\d+)/, "$1.$2");
      break;
    case 6:
    case 7:
    case 8:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d+)/, "$1.$2.$3");
      break;
    case 9:
    case 10:
    case 11:
    case 12:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d{3})(\d+)/, "$1.$2.$3/$4");
      break;
    case 13:
    case 14:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d+)/, "$1.$2.$3/$4-$5");
      break;
  }
};
cnpjMask$1.cnpjMask = cnpjMask;
var cpfCnpjMask$1 = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(cpfCnpjMask$1, "__esModule", { value: true });
cpfCnpjMask$1.cpfCnpjMask = void 0;
var chunkSubstr_1 = __importDefault(chunkSubstr$1);
var cpfCnpjMask = function(e) {
  var element = e.target;
  element.value = element.value.replace(/\D/g, "");
  if (element.value.length > 14) {
    element.value = element.value.slice(0, 14);
  }
  var arr = [""];
  switch (element.value.length) {
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      arr = (0, chunkSubstr_1.default)(element.value, 3);
      element.value = arr.join(".");
      break;
    case 10:
    case 11:
      element.value = element.value.replace(/(\d{3})(\d{3})(\d{3})(\d+)/, "$1.$2.$3-$4");
      break;
    case 12:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d{3})(\d{4})/, "$1.$2.$3/$4");
      break;
    case 13:
    case 14:
      element.value = element.value.replace(/(\d{2})(\d{3})(\d{3})(\d{4})(\d+)/, "$1.$2.$3/$4-$5");
      break;
  }
};
cpfCnpjMask$1.cpfCnpjMask = cpfCnpjMask;
var phoneMask$1 = {};
Object.defineProperty(phoneMask$1, "__esModule", { value: true });
phoneMask$1.phoneMask = void 0;
var phoneMask = function(e) {
  var element = e.target;
  element.value = element.value.replace(/\D/g, "");
  if (element.value.length > 11) {
    element.value = element.value.slice(0, 11);
  }
  switch (element.value.length) {
    case 2:
      if (e.key.toLowerCase() !== "backspace")
        element.value = element.value.replace(/(\d{2})/, "($1) ");
      break;
    case 3:
    case 4:
    case 5:
    case 6:
      element.value = element.value.replace(/(\d{2})(\d+)/, "($1) $2");
      break;
    case 7:
    case 8:
    case 9:
    case 10:
      element.value = element.value.replace(/(\d{2})(\d{4})(\d+)/, "($1) $2-$3");
      break;
    case 11:
      element.value = element.value.replace(/(\d{2})(\d{5})(\d{4})/, "($1) $2-$3");
      break;
  }
};
phoneMask$1.phoneMask = phoneMask;
(function(exports) {
  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() {
      return m[k];
    } });
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(cepMask$1, exports);
  __exportStar(cpfMask$1, exports);
  __exportStar(cnpjMask$1, exports);
  __exportStar(cpfCnpjMask$1, exports);
  __exportStar(phoneMask$1, exports);
})(lib);
function isCepValid(value) {
  value = value.replace(/\D/g, "");
  if (value.length !== 8)
    return false;
  else
    return true;
}
function isCpfCnpjValid(value) {
  var _a;
  value = value.replace(/\D/g, "");
  if (value.length !== 11 && value.length !== 14)
    return false;
  else {
    if ((_a = value.match(/^(\d)\1*$/)) == null ? void 0 : _a.length)
      return false;
    if (value.length === 11) {
      let sum;
      let rest;
      sum = 0;
      for (let i = 1; i <= 9; i++)
        sum = sum + parseInt(value.substring(i - 1, i)) * (11 - i);
      rest = sum * 10 % 11;
      if (rest == 10 || rest == 11)
        rest = 0;
      if (rest != parseInt(value.substring(9, 10)))
        return false;
      sum = 0;
      for (let i = 1; i <= 10; i++)
        sum = sum + parseInt(value.substring(i - 1, i)) * (12 - i);
      rest = sum * 10 % 11;
      if (rest == 10 || rest == 11)
        rest = 0;
      if (rest != parseInt(value.substring(10, 11)))
        return false;
    }
    if (value.length === 14) {
      let length = value.length - 2;
      let numbers = value.substring(0, length);
      const digits = value.substring(length);
      let sum = 0;
      let pos = length - 7;
      for (let i = length; i >= 1; i--) {
        sum += Number(numbers.charAt(length - i)) * pos--;
        if (pos < 2)
          pos = 9;
      }
      let resultado = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (resultado != Number(digits.charAt(0)))
        return false;
      length = length + 1;
      numbers = value.substring(0, length);
      sum = 0;
      pos = length - 7;
      for (let i = length; i >= 1; i--) {
        sum += Number(numbers.charAt(length - i)) * pos--;
        if (pos < 2)
          pos = 9;
      }
      resultado = sum % 11 < 2 ? 0 : 11 - sum % 11;
      if (resultado != Number(digits.charAt(1)))
        return false;
    }
  }
  return true;
}
function isPhoneNumberValid(value) {
  value = value.replace(/\D/g, "");
  if (value.length !== 10 && value.length !== 11)
    return false;
  else
    return true;
}
const phoneNumberValidator$1 = (value) => !common.req(value) || isCepValid(value);
const cepErrorMsg = (cep) => {
  cep = cep.replace(/\D/g, "");
  let msg = "";
  if (cep.length !== 8)
    msg = "Formato inv\xE1lido de CEP!";
  return msg;
};
const cepValidation = (stateRef) => common.withMessage(() => cepErrorMsg(stateRef.cep), phoneNumberValidator$1);
const cpfCnpjValidator = (value) => !common.req(value) || isCpfCnpjValid(value);
const cpfCnpjErrorMsg = (cpf_cnpj) => {
  let msg = "";
  if (cpf_cnpj.length === 18)
    msg = "CNPJ inv\xE1lido!";
  if (cpf_cnpj.length < 18)
    msg = "Formato inv\xE1lido de CNPJ";
  if (cpf_cnpj.length === 14)
    msg = "CPF inv\xE1lido!";
  if (cpf_cnpj.length < 14)
    msg = "Formato inv\xE1lido de CPF!";
  return msg;
};
const cpfCnpjValidation = (stateRef) => common.withMessage(() => cpfCnpjErrorMsg(stateRef.cpf_cnpj), cpfCnpjValidator);
const phoneNumberValidator = (value) => !common.req(value) || isPhoneNumberValid(value);
const phoneErrorMsg = (phoneNumber) => {
  phoneNumber = phoneNumber.replace(/\D/g, "");
  let msg = "";
  if (phoneNumber.length !== 10 && phoneNumber.length !== 11)
    msg = "Formato inv\xE1lido de telefone!";
  return msg;
};
const phoneValidation = (stateRef) => common.withMessage(() => phoneErrorMsg(stateRef.phoneNumber), phoneNumberValidator);
const _hoisted_1$9 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$9 = { key: 1 };
const _hoisted_3$8 = { class: "animate-spin block h-6 w-6 m-auto text-gray-500" };
const _hoisted_4$8 = ["required"];
const _hoisted_5$4 = { key: 0 };
const _hoisted_6$1 = { class: "ml-2 text-red-600" };
const _sfc_main$9 = /* @__PURE__ */ defineComponent({
  props: __spreadValues({}, commonProps),
  emits: ["value", "error", "address"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      isLoading: false,
      focus: false,
      cep: props.inputValue
    });
    const rules = computed(() => ({
      cep: {
        cepValidator: cepValidation(state)
      }
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.cep = __spreadProps(__spreadValues({}, rules.value.cep), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.cep);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "cep");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "cepHasError" });
    }
    function cepInput(e) {
      const element = e.target;
      if (element.value !== state.cep)
        lib.cepMask(e);
      emit("value", element.value);
      state.cep = element.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-2",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$9, [
            createVNode(unref(render$7))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "CEP", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).cep.$error ? "text-red-400" : ""])
          }, [
            !unref(state).isLoading ? (openBlock(), createBlock(unref(render$5), { key: 0 })) : (openBlock(), createElementBlock("div", _hoisted_2$9, [
              createElementVNode("span", _hoisted_3$8, [
                createVNode(unref(render$3), { class: "scale-x-[-1]" })
              ])
            ]))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).cep = $event),
            autocomplete: "nop",
            type: "text",
            maxlength: "10",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onKeyup: cepInput
          }, null, 42, _hoisted_4$8), [
            [
              vModelText,
              unref(state).cep,
              void 0,
              { lazy: true }
            ]
          ])
        ], 2),
        unref(v$).cep.$error ? (openBlock(), createElementBlock("span", _hoisted_5$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).cep.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_6$1, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$8 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$8 = ["required"];
const _hoisted_3$7 = { key: 0 };
const _hoisted_4$7 = { class: "ml-2 text-red-600" };
const _sfc_main$8 = /* @__PURE__ */ defineComponent({
  props: __spreadValues({}, commonProps),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      city: props.inputValue
    });
    watch(() => props.inputValue, (newValue) => state.city = newValue);
    const rules = computed(() => ({
      city: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.city = __spreadProps(__spreadValues({}, rules.value.city), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.city);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "city");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "cityHasError" });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$8, [
            createVNode(unref(render$8))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "Cidade", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).city.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).city = $event),
            autocomplete: "nop",
            type: "text",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: _cache[1] || (_cache[1] = () => emit("value", unref(state).city))
          }, null, 42, _hoisted_2$8), [
            [
              vModelText,
              unref(state).city,
              void 0,
              { trim: true }
            ]
          ])
        ], 2),
        unref(v$).city.$error ? (openBlock(), createElementBlock("span", _hoisted_3$7, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).city.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_4$7, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$7 = {
  key: 0,
  class: "flex items-center justify-center h-7 w-7 bg-gray-400 border border-gray-400 text-white rounded-l-md p-[6px] box-content"
};
const _hoisted_2$7 = ["required", "disabled"];
const _hoisted_3$6 = {
  key: 1,
  class: "absolute w-full h-full translate-y-[-4px] bg-white bg-opacity-40"
};
const _hoisted_4$6 = { key: 0 };
const _hoisted_5$3 = { class: "ml-2 text-red-600" };
const _sfc_main$7 = /* @__PURE__ */ defineComponent({
  props: __spreadProps(__spreadValues({}, commonProps), {
    disabled: {
      type: Boolean,
      default: false
    }
  }),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      cpf_cnpj: props.inputValue
    });
    const rules = computed(() => ({
      cpf_cnpj: {
        cpfCnpjValidator: cpfCnpjValidation(state)
      }
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.cpf_cnpj = __spreadProps(__spreadValues({}, rules.value.cpf_cnpj), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.cpf_cnpj);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "cpf_cnpj");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", {
        error: v$.value.$error,
        propName: "registrationIdHasError"
      });
    }
    function cpfCnpjInput(e) {
      const element = e.target;
      if (element.value !== state.cpf_cnpj)
        lib.cpfCnpjMask(e);
      emit("value", element.value);
      state.cpf_cnpj = element.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-3",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$7, [
            createVNode(unref(render$a))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "CPF ou CNPJ", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).cpf_cnpj.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).cpf_cnpj = $event),
            autocomplete: "nop",
            type: "text",
            maxlength: "18",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            disabled: props.disabled,
            onFocus,
            onBlur,
            onKeyup: cpfCnpjInput
          }, null, 42, _hoisted_2$7), [
            [
              vModelText,
              unref(state).cpf_cnpj,
              void 0,
              { lazy: true }
            ]
          ]),
          props.disabled ? (openBlock(), createElementBlock("div", _hoisted_3$6)) : createCommentVNode("", true)
        ], 2),
        unref(v$).cpf_cnpj.$error ? (openBlock(), createElementBlock("span", _hoisted_4$6, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).cpf_cnpj.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_5$3, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$6 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$6 = ["required", "disabled"];
const _hoisted_3$5 = {
  key: 1,
  class: "absolute w-full h-full translate-y-[-4px] bg-white bg-opacity-40"
};
const _hoisted_4$5 = { key: 0 };
const _hoisted_5$2 = { class: "ml-2 text-red-600" };
const _sfc_main$6 = /* @__PURE__ */ defineComponent({
  props: __spreadProps(__spreadValues({}, commonProps), {
    disabled: {
      type: Boolean,
      default: false
    }
  }),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      email: props.inputValue
    });
    email.$message = "Formato inv\xE1lido de e-mail!";
    required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
    const rules = computed(() => ({
      email: { email }
    }));
    if (props.required) {
      rules.value.email = __spreadProps(__spreadValues({}, rules.value.email), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.email);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "email");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "emailHasError" });
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$6, [
            createVNode(unref(render$g))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "E-mail", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).email.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$7))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).email = $event),
            type: "email",
            name: "email-rde",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            disabled: props.disabled,
            onFocus,
            onBlur,
            onInput: _cache[1] || (_cache[1] = () => emit("value", unref(state).email))
          }, null, 42, _hoisted_2$6), [
            [
              vModelText,
              unref(state).email,
              void 0,
              { trim: true }
            ]
          ]),
          props.disabled ? (openBlock(), createElementBlock("div", _hoisted_3$5)) : createCommentVNode("", true)
        ], 2),
        unref(v$).email.$error ? (openBlock(), createElementBlock("span", _hoisted_4$5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).email.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_5$2, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const _hoisted_1$5 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$5 = ["required"];
const _hoisted_3$4 = { key: 0 };
const _hoisted_4$4 = { class: "ml-2 text-red-600" };
const _sfc_main$5 = /* @__PURE__ */ defineComponent({
  props: __spreadProps(__spreadValues({}, commonProps), {
    isEnterprise: {
      type: Boolean,
      default: false
    }
  }),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      name: props.inputValue
    });
    const rules = computed(() => ({
      name: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.name = __spreadProps(__spreadValues({}, rules.value.name), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.name);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "name");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "nameHasError" });
    }
    function handleNameInput(e) {
      const element = e.target;
      if (props.isEnterprise)
        element.value = element.value.toUpperCase();
      emit("value", element.value);
      state.name = element.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-3",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$5, [
            props.isEnterprise ? (openBlock(), createBlock(unref(render$f), { key: 0 })) : (openBlock(), createBlock(unref(render$1), { key: 1 }))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, toDisplayString(__props.isEnterprise ? "Nome ou raz\xE3o social" : "Nome completo"), 3),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).name.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).name = $event),
            autocomplete: "nop",
            type: "text",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: handleNameInput
          }, null, 42, _hoisted_2$5), [
            [
              vModelText,
              unref(state).name,
              void 0,
              {
                lazy: true,
                trim: true
              }
            ]
          ])
        ], 2),
        unref(v$).name.$error ? (openBlock(), createElementBlock("span", _hoisted_3$4, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).name.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_4$4, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$4 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content font-semibold"
};
const _hoisted_2$4 = ["required"];
const _hoisted_3$3 = { key: 0 };
const _hoisted_4$3 = { class: "ml-2 text-red-600" };
const _sfc_main$4 = /* @__PURE__ */ defineComponent({
  props: __spreadValues({}, commonProps),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      number: props.inputValue
    });
    watch(() => props.inputValue, (newValue) => state.number = newValue);
    const rules = computed(() => ({
      number: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.number = __spreadProps(__spreadValues({}, rules.value.number), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.number);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "number");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "numberHasError" });
    }
    function numberInput(e) {
      const element = e.target;
      element.value = element.value.replace(/\D/g, "");
      emit("value", element.value);
      state.number = element.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-2",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$4, [
            createVNode(unref(render$c))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "N\xFAmero", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).number.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).number = $event),
            autocomplete: "nop",
            type: "text",
            maxlength: "6",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: numberInput
          }, null, 42, _hoisted_2$4), [
            [
              vModelText,
              unref(state).number,
              void 0,
              {
                lazy: true,
                trim: true
              }
            ]
          ])
        ], 2),
        unref(v$).number.$error ? (openBlock(), createElementBlock("span", _hoisted_3$3, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).number.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_4$3, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$3 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$3 = ["required"];
const _hoisted_3$2 = ["onClick"];
const _hoisted_4$2 = { key: 0 };
const _hoisted_5$1 = { class: "ml-2 text-red-600" };
const _sfc_main$3 = /* @__PURE__ */ defineComponent({
  props: {
    required: {
      type: Boolean,
      default: false
    },
    externalDescribeIcon: {
      type: Boolean,
      default: true
    },
    label: {
      type: String,
      default: "Senha"
    }
  },
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      password: "",
      showPass: false
    });
    const passwordInput = ref({});
    onMounted(() => {
      setTimeout(() => {
        passwordInput.value.disabled = false;
      }, 1e3);
    });
    const rules = computed(() => ({
      password: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.password = { required };
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.password);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "password");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "passwordHasError" });
    }
    function showPass() {
      state.showPass = !state.showPass;
      passwordInput.value.type = passwordInput.value.type === "password" ? "text" : "password";
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$3, [
            createVNode(unref(render$9))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, toDisplayString(props.label), 3),
          withDirectives(createElementVNode("input", {
            ref_key: "passwordInput",
            ref: passwordInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).password = $event),
            disabled: "",
            type: "password",
            name: "password-rde",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: _cache[1] || (_cache[1] = () => emit("value", unref(state).password))
          }, null, 42, _hoisted_2$3), [
            [
              vModelText,
              unref(state).password,
              void 0,
              { trim: true }
            ]
          ]),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).password.$error ? "text-red-400" : ""]),
            onClick: withModifiers(showPass, ["stop", "prevent"])
          }, [
            !unref(state).showPass ? (openBlock(), createBlock(unref(render$d), { key: 0 })) : (openBlock(), createBlock(unref(render$e), { key: 1 }))
          ], 10, _hoisted_3$2)
        ], 2),
        unref(v$).password.$error ? (openBlock(), createElementBlock("span", _hoisted_4$2, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).password.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_5$1, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ], 64);
    };
  }
});
const _hoisted_1$2 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$2 = ["required"];
const _hoisted_3$1 = { key: 0 };
const _hoisted_4$1 = { class: "ml-2 text-red-600" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  props: __spreadProps(__spreadValues({}, commonProps), {
    label: {
      type: String,
      default: "Telefone"
    }
  }),
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      phoneNumber: props.inputValue
    });
    const rules = computed(() => ({
      phoneNumber: {
        phoneValidator: phoneValidation(state)
      }
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.phoneNumber = __spreadProps(__spreadValues({}, rules.value.phoneNumber), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.phoneNumber);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "phoneNumber");
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", {
        error: v$.value.$error,
        propName: "phoneNumberHasError"
      });
    }
    function phoneNumberInput(e) {
      const element = e.target;
      if (element.value !== state.phoneNumber)
        lib.phoneMask(e);
      emit("value", element.value);
      state.phoneNumber = element.value;
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-2",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$2, [
            createVNode(unref(render$4))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, toDisplayString(props.label), 3),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).phoneNumber.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).phoneNumber = $event),
            autocomplete: "nop",
            type: "text",
            maxlength: "15",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onKeyup: phoneNumberInput
          }, null, 42, _hoisted_2$2), [
            [
              vModelText,
              unref(state).phoneNumber,
              void 0,
              { lazy: true }
            ]
          ])
        ], 2),
        unref(v$).phoneNumber.$error ? (openBlock(), createElementBlock("span", _hoisted_3$1, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).phoneNumber.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_4$1, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
const _hoisted_1$1 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2$1 = { class: "block h-6 w-6 absolute right-2 text-gray-400" };
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  props: {
    externalDescribeIcon: {
      type: Boolean,
      default: true
    }
  },
  emits: ["value"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      input_value: ""
    });
    function clearInput() {
      state.input_value = "";
      emit("value", "");
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex w-full",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1$1, [
            createVNode(unref(render$2))
          ])) : createCommentVNode("", true),
          createElementVNode("span", _hoisted_2$1, [
            unref(state).input_value.length > 0 ? (openBlock(), createBlock(unref(render), {
              key: 0,
              class: "cursor-pointer animate-animated animate-zoomIn animate-faster",
              onClick: clearInput
            })) : (openBlock(), createBlock(unref(render$2), {
              key: 1,
              class: "animate-animated animate-zoomIn animate-faster"
            }))
          ]),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).input_value = $event),
            type: "text",
            autocomplete: "nop",
            placeholder: "Digite para filtrar...",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", props.externalDescribeIcon ? "rounded-r-md" : "rounded-md"]),
            onKeyup: _cache[1] || (_cache[1] = () => emit("value", unref(state).input_value))
          }, null, 34), [
            [vModelText, unref(state).input_value]
          ])
        ], 2)
      ]);
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "flex items-center justify-center h-6 w-6 bg-gray-400 border border-gray-400 text-white rounded-l-md p-2 box-content"
};
const _hoisted_2 = ["required"];
const _hoisted_3 = { id: "states" };
const _hoisted_4 = ["value"];
const _hoisted_5 = { key: 0 };
const _hoisted_6 = { class: "ml-2 text-red-600" };
const _sfc_main = /* @__PURE__ */ defineComponent({
  props: {
    required: {
      type: Boolean,
      default: false
    },
    externalDescribeIcon: {
      type: Boolean,
      default: true
    },
    inputValue: {
      type: String,
      default: ""
    }
  },
  emits: ["value", "error"],
  setup(__props, { emit }) {
    const props = __props;
    const state = reactive({
      focus: false,
      state: props.inputValue
    });
    watch(() => props.inputValue, (newValue) => state.state = newValue);
    const rules = computed(() => ({
      state: {}
    }));
    if (props.required) {
      required.$message = "Preenchimento do campo \xE9 obrigat\xF3rio!";
      rules.value.state = __spreadProps(__spreadValues({}, rules.value.state), { required });
    }
    const v$ = useVuelidate(rules, state);
    const classInput = inputClass(props.externalDescribeIcon, v$.value.state);
    const classLabelSpan = labelSpanClass(props.externalDescribeIcon, state, "state");
    const statesList = [
      "AC",
      "AL",
      "AP",
      "AM",
      "BA",
      "CE",
      "DF",
      "ES",
      "GO",
      "MA",
      "MT",
      "MS",
      "MG",
      "PA",
      "PB",
      "PR",
      "PE",
      "PI",
      "RJ",
      "RN",
      "RS",
      "RO",
      "RR",
      "SC",
      "SP",
      "SE",
      "TO"
    ];
    function onFocus() {
      state.focus = true;
    }
    function onBlur() {
      state.focus = false;
      v$.value.$touch();
      emit("error", { error: v$.value.$error, propName: "stateHasError" });
    }
    function stateInput(e) {
      const element = e.target;
      element.value = element.value.replace(/\d/g, "").toUpperCase();
      if (element.value.length === 1)
        element.value = element.value.replace(/[^ABCDEGMPRST]/, "");
      element.value = element.value.replace(/[^ABCDEFGILMNOPRST]/, "");
      if (element.value.length === 2) {
        if (statesList.includes(element.value)) {
          emit("value", element.value);
          state.state = element.value;
        } else
          element.value = element.value.slice(0, 1);
      }
      if (element.value.length > 2) {
        element.value = element.value.slice(0, 2);
      }
    }
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("label", {
          class: normalizeClass([
            "relative flex pt-6 mt-2 w-full col-span-2",
            props.externalDescribeIcon ? "items-center" : "flex-col justify-center"
          ])
        }, [
          props.externalDescribeIcon ? (openBlock(), createElementBlock("span", _hoisted_1, [
            createVNode(unref(render$6))
          ])) : createCommentVNode("", true),
          createElementVNode("span", {
            class: normalizeClass(["absolute transition-all duration-300 font-semibold", unref(classLabelSpan)])
          }, "Estado", 2),
          createElementVNode("span", {
            class: normalizeClass(["block h-6 w-6 absolute right-2 text-gray-400", unref(v$).state.$error ? "text-red-400" : ""])
          }, [
            createVNode(unref(render$5))
          ], 2),
          withDirectives(createElementVNode("input", {
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => unref(state).state = $event),
            type: "text",
            list: "states",
            autocomplete: "nop",
            maxlength: "2",
            class: normalizeClass(["w-full border-gray-400 text-gray-800", unref(classInput)]),
            required: props.required,
            onFocus,
            onBlur,
            onInput: stateInput
          }, null, 42, _hoisted_2), [
            [
              vModelText,
              unref(state).state,
              void 0,
              {
                lazy: true,
                trim: true
              }
            ]
          ]),
          createElementVNode("datalist", _hoisted_3, [
            (openBlock(), createElementBlock(Fragment, null, renderList(statesList, (regionState, idx) => {
              return createElementVNode("option", {
                key: `${idx}-${regionState}`,
                value: regionState
              }, null, 8, _hoisted_4);
            }), 64))
          ])
        ], 2),
        unref(v$).state.$error ? (openBlock(), createElementBlock("span", _hoisted_5, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(unref(v$).state.$errors, (error, index2) => {
            return openBlock(), createElementBlock("span", { key: index2 }, [
              createElementVNode("small", _hoisted_6, toDisplayString(error.$message), 1)
            ]);
          }), 128))
        ])) : createCommentVNode("", true)
      ]);
    };
  }
});
export { _sfc_main$a as AddressInput, _sfc_main$9 as CepInput, _sfc_main$8 as CityInput, _sfc_main$7 as CpfCnpjInput, _sfc_main$6 as EmailInput, _sfc_main$5 as NameInput, _sfc_main$4 as NumberAddressInput, _sfc_main$3 as PasswordInput, _sfc_main$2 as PhoneNumberInput, _sfc_main$1 as SearchBoxInput, _sfc_main as StateInput };
